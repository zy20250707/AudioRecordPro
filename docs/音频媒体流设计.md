# 音频录制 MediaStream 设计方案

## 设计目标

基于 Web API MediaStream 的设计理念，为音频录制场景设计合理的轨道架构：
- **麦克风录制**
- **系统音频输出录制**
- **混合录制**（麦克风 + 系统音频）

## 核心设计理念

### 1. **轨道类型定义**

```swift
enum AudioTrackType {
    case microphone     // 麦克风轨道
    case systemOutput   // 系统音频输出轨道
    case processOutput  // 特定进程音频轨道
}

enum AudioTrackSource {
    case device(deviceId: String)           // 具体设备
    case systemMixdown                      // 系统混音输出
    case process(pid: pid_t, name: String)  // 特定进程
}
```

### 2. **AudioMediaStream 设计**

```swift
class AudioMediaStream: MediaStream {
    private var audioTracks: [AudioMediaStreamTrack] = []
    
    // 获取不同类型的轨道
    func getMicrophoneTracks() -> [AudioMediaStreamTrack] {
        return audioTracks.filter { $0.trackType == .microphone }
    }
    
    func getSystemOutputTracks() -> [AudioMediaStreamTrack] {
        return audioTracks.filter { $0.trackType == .systemOutput }
    }
    
    func getProcessOutputTracks() -> [AudioMediaStreamTrack] {
        return audioTracks.filter { $0.trackType == .processOutput }
    }
    
    // 录制模式判断
    var recordingMode: RecordingMode {
        let hasMic = !getMicrophoneTracks().isEmpty
        let hasSystem = !getSystemOutputTracks().isEmpty || !getProcessOutputTracks().isEmpty
        
        switch (hasMic, hasSystem) {
        case (true, false):
            return .microphoneOnly
        case (false, true):
            return .systemAudioOnly
        case (true, true):
            return .mixedAudio
        case (false, false):
            return .inactive
        }
    }
}
```

### 3. **AudioMediaStreamTrack 设计**

```swift
class AudioMediaStreamTrack: MediaStreamTrack {
    let trackType: AudioTrackType
    let source: AudioTrackSource
    let audioFormat: AudioFormat
    
    // 音频特有属性
    var volume: Float = 1.0
    var isMuted: Bool = false
    var sampleRate: Double
    var channelCount: Int
    
    // 音频处理选项
    var echoCancellation: Bool = false
    var noiseSuppression: Bool = false
    var autoGainControl: Bool = false
    
    init(type: AudioTrackType, source: AudioTrackSource, format: AudioFormat) {
        self.trackType = type
        self.source = source
        self.audioFormat = format
        self.sampleRate = format.sampleRate
        self.channelCount = Int(format.channelCount)
        super.init(kind: "audio")
    }
    
    // 轨道控制
    func setVolume(_ volume: Float) {
        self.volume = max(0.0, min(1.0, volume))
    }
    
    func mute() {
        self.isMuted = true
    }
    
    func unmute() {
        self.isMuted = false
    }
}
```

## 三种录制模式的轨道设计

### 1. **纯麦克风录制**

```swift
// 创建麦克风流
func createMicrophoneStream(deviceId: String = "default") async throws -> AudioMediaStream {
    let stream = AudioMediaStream()
    
    // 创建麦克风轨道
    let micTrack = AudioMediaStreamTrack(
        type: .microphone,
        source: .device(deviceId: deviceId),
        format: AudioFormat.standard48kHz
    )
    
    // 配置音频处理
    micTrack.echoCancellation = true
    micTrack.noiseSuppression = true
    micTrack.autoGainControl = true
    
    stream.addTrack(micTrack)
    return stream
}

// 使用示例
let micStream = try await createMicrophoneStream()
print("录制模式:", micStream.recordingMode) // .microphoneOnly
print("轨道数量:", micStream.getAudioTracks().count) // 1
```

### 2. **系统音频录制**

```swift
// 创建系统音频流
func createSystemAudioStream(targetProcess: pid_t? = nil) async throws -> AudioMediaStream {
    let stream = AudioMediaStream()
    
    if let pid = targetProcess {
        // 特定进程音频轨道
        let processName = ProcessUtils.getProcessName(pid: pid)
        let processTrack = AudioMediaStreamTrack(
            type: .processOutput,
            source: .process(pid: pid, name: processName),
            format: AudioFormat.standard48kHz
        )
        stream.addTrack(processTrack)
    } else {
        // 系统混音轨道
        let systemTrack = AudioMediaStreamTrack(
            type: .systemOutput,
            source: .systemMixdown,
            format: AudioFormat.standard48kHz
        )
        stream.addTrack(systemTrack)
    }
    
    return stream
}

// 使用示例
let systemStream = try await createSystemAudioStream()
print("录制模式:", systemStream.recordingMode) // .systemAudioOnly

let musicStream = try await createSystemAudioStream(targetProcess: 1234)
print("进程轨道:", musicStream.getProcessOutputTracks().count) // 1
```

### 3. **混合录制**

```swift
// 创建混合音频流
func createMixedAudioStream(
    microphoneDeviceId: String = "default",
    targetProcess: pid_t? = nil
) async throws -> AudioMediaStream {
    let stream = AudioMediaStream()
    
    // 添加麦克风轨道
    let micTrack = AudioMediaStreamTrack(
        type: .microphone,
        source: .device(deviceId: microphoneDeviceId),
        format: AudioFormat.standard48kHz
    )
    micTrack.echoCancellation = true
    micTrack.volume = 0.8  // 麦克风音量稍低
    stream.addTrack(micTrack)
    
    // 添加系统音频轨道
    if let pid = targetProcess {
        let processName = ProcessUtils.getProcessName(pid: pid)
        let processTrack = AudioMediaStreamTrack(
            type: .processOutput,
            source: .process(pid: pid, name: processName),
            format: AudioFormat.standard48kHz
        )
        processTrack.volume = 1.0  // 系统音频保持原音量
        stream.addTrack(processTrack)
    } else {
        let systemTrack = AudioMediaStreamTrack(
            type: .systemOutput,
            source: .systemMixdown,
            format: AudioFormat.standard48kHz
        )
        systemTrack.volume = 1.0
        stream.addTrack(systemTrack)
    }
    
    return stream
}

// 使用示例
let mixedStream = try await createMixedAudioStream(targetProcess: 1234)
print("录制模式:", mixedStream.recordingMode) // .mixedAudio
print("麦克风轨道:", mixedStream.getMicrophoneTracks().count) // 1
print("进程轨道:", mixedStream.getProcessOutputTracks().count) // 1
```

## 轨道管理和控制

### 1. **动态轨道管理**

```swift
// 运行时添加/移除轨道
extension AudioMediaStream {
    func addMicrophoneTrack(deviceId: String = "default") async throws {
        let micTrack = AudioMediaStreamTrack(
            type: .microphone,
            source: .device(deviceId: deviceId),
            format: AudioFormat.standard48kHz
        )
        addTrack(micTrack)
        
        // 触发模式变化事件
        onRecordingModeChanged?(recordingMode)
    }
    
    func addProcessTrack(pid: pid_t) async throws {
        let processName = ProcessUtils.getProcessName(pid: pid)
        let processTrack = AudioMediaStreamTrack(
            type: .processOutput,
            source: .process(pid: pid, name: processName),
            format: AudioFormat.standard48kHz
        )
        addTrack(processTrack)
        
        onRecordingModeChanged?(recordingMode)
    }
    
    func removeMicrophoneTracks() {
        let micTracks = getMicrophoneTracks()
        micTracks.forEach { removeTrack($0) }
        onRecordingModeChanged?(recordingMode)
    }
}
```

### 2. **轨道状态监控**

```swift
extension AudioMediaStreamTrack {
    // 监听轨道状态变化
    func onTrackStateChanged(_ callback: @escaping (MediaStreamTrackState) -> Void) {
        self.onStateChanged = callback
    }
    
    // 监听音频电平
    func onAudioLevelChanged(_ callback: @escaping (Float) -> Void) {
        self.onLevelChanged = callback
    }
    
    // 监听设备断开
    func onDeviceDisconnected(_ callback: @escaping () -> Void) {
        self.onDeviceDisconnected = callback
    }
}
```

### 3. **错误处理和恢复**

```swift
extension AudioMediaStream {
    func handleTrackError(_ track: AudioMediaStreamTrack, error: Error) {
        switch track.trackType {
        case .microphone:
            // 麦克风错误 - 尝试重新连接或使用默认设备
            Task {
                try await reconnectMicrophone(track)
            }
            
        case .systemOutput, .processOutput:
            // 系统音频错误 - 可能进程已退出
            if case .process(let pid, _) = track.source {
                if !ProcessUtils.isProcessRunning(pid: pid) {
                    removeTrack(track)
                    onProcessTerminated?(pid)
                }
            }
        }
    }
    
    private func reconnectMicrophone(_ track: AudioMediaStreamTrack) async throws {
        // 尝试重新连接麦克风
        track.readyState = .ended
        
        // 创建新的麦克风轨道
        let newTrack = AudioMediaStreamTrack(
            type: .microphone,
            source: track.source,
            format: track.audioFormat
        )
        
        removeTrack(track)
        addTrack(newTrack)
    }
}
```

## 实际使用示例

### 1. **Web API 兼容调用**

```javascript
// 前端调用 - 与标准 Web API 完全一致
const stream = await navigator.mediaDevices.getUserMedia({
  audio: {
    includeSystemAudio: true,  // 扩展属性
    targetProcess: 'Music',    // 扩展属性
    echoCancellation: true
  }
});

// 检查录制模式
console.log('录制模式:', stream.recordingMode); // 'mixedAudio'

// 获取不同类型的轨道
const micTracks = stream.getMicrophoneTracks();
const systemTracks = stream.getSystemOutputTracks();

// 控制轨道
micTracks[0].setVolume(0.8);
systemTracks[0].setVolume(1.0);
```

### 2. **录制器集成**

```swift
class AudioRecorder {
    private var stream: AudioMediaStream?
    private var mixedRecorder: MixedAudioRecorder?
    
    func startRecording(stream: AudioMediaStream) async throws {
        self.stream = stream
        
        switch stream.recordingMode {
        case .microphoneOnly:
            try await startMicrophoneRecording(stream)
        case .systemAudioOnly:
            try await startSystemAudioRecording(stream)
        case .mixedAudio:
            try await startMixedRecording(stream)
        case .inactive:
            throw AudioRecorderError.noActiveTracks
        }
    }
    
    private func startMixedRecording(_ stream: AudioMediaStream) async throws {
        mixedRecorder = MixedAudioRecorder()
        
        // 配置麦克风轨道
        let micTracks = stream.getMicrophoneTracks()
        for track in micTracks {
            try await mixedRecorder?.addMicrophoneSource(track)
        }
        
        // 配置系统音频轨道
        let systemTracks = stream.getSystemOutputTracks()
        let processTracks = stream.getProcessOutputTracks()
        
        for track in systemTracks + processTracks {
            try await mixedRecorder?.addSystemAudioSource(track)
        }
        
        try await mixedRecorder?.startRecording()
    }
}
```

## 设计优势

### 1. **清晰的职责分离**
- 每个轨道负责一种音频源
- 流负责轨道的组合和管理
- 录制器负责实际的音频处理

### 2. **灵活的组合方式**
- 支持任意数量的麦克风轨道
- 支持多个进程音频轨道
- 支持运行时动态添加/移除

### 3. **完整的状态管理**
- 轨道级别的状态控制
- 流级别的模式判断
- 错误处理和自动恢复

### 4. **Web API 兼容性**
- 保持标准 API 的调用方式
- 在兼容基础上扩展功能
- 渐进式增强支持

这个设计既保持了 Web API 的设计理念，又充分利用了 macOS 的系统级音频能力！

