import Cocoa
import Foundation

// AudioProcessInfo ç±»å‹å·²åœ¨ CoreAudioProcessTapRecorder.swift ä¸­å®šä¹‰

/// ä¸»çª—å£è§†å›¾ - åˆ†å‰²è§†å›¾å®ç°
class MainWindowView: NSView, NSTableViewDataSource, NSTableViewDelegate {
    
    // MARK: - Split Layout
    private let splitView = NSSplitView()
    private let sidebarView = NSView()
    private let contentView = NSView()
    
    // MARK: - Sidebar Controls
    private let systemHeader = NSTextField()
    private let micHeader = NSTextField()
    private let appsHeader = NSTextField()
    private let systemCheckbox = NSButton(checkboxWithTitle: "ç³»ç»ŸéŸ³é¢‘è¾“å‡º", target: nil, action: nil)
    private let microphoneCheckbox = NSButton(checkboxWithTitle: "éº¦å…‹é£", target: nil, action: nil)
    private let appsScroll = NSScrollView()
    private let appsTable = NSTableView()
    private let appsColumn = NSTableColumn(identifier: NSUserInterfaceItemIdentifier("app"))
    private var availableProcesses: [AudioProcessInfo] = []
    
    // MARK: - Content (Right)
    private let containerStack = NSStackView()
    private let welcomeLabel = NSTextField()
    private let statusLabel = NSTextField()
    private let timerLabel = NSTextField()
    private let recordButton = NSButton()
    private let tracksStack = NSStackView()
    private let bigTimerLabel = NSTextField()
    private let bigButtonContainer = NSView()
    private let bigRecordButton = NSButton()
    private let statusBarView = NSView()
    private let statusBarText = NSTextField()
    private var bigRecordButtonWidthConstraint: NSLayoutConstraint?
    private var bigRecordButtonHeightConstraint: NSLayoutConstraint?
    private let outerRingLayer = CAShapeLayer()
    
    // MARK: - Properties
    weak var delegate: MainWindowViewDelegate?
    private var currentRecordingState: RecordingState = .idle
    private let bigRecordInnerSquare = CALayer()
    
    // MARK: - Initialization
    override init(frame frameRect: NSRect) {
        super.init(frame: frameRect)
        setupView()
    }
    
    required init?(coder: NSCoder) {
        super.init(coder: coder)
        setupView()
    }
    
    private func setupView() {
        // èƒŒæ™¯è‰²
        wantsLayer = true
        layer?.backgroundColor = NSColor.windowBackgroundColor.cgColor
        
        // SplitView åŸºæœ¬å±æ€§
        splitView.isVertical = true
        splitView.dividerStyle = .thin
        splitView.translatesAutoresizingMaskIntoConstraints = false
        addSubview(splitView)
        
        // å·¦ä¾§ä¸å³ä¾§å®¹å™¨
        sidebarView.wantsLayer = true
        sidebarView.layer?.backgroundColor = NSColor.controlBackgroundColor.cgColor
        sidebarView.translatesAutoresizingMaskIntoConstraints = false
        contentView.wantsLayer = true
        contentView.layer?.backgroundColor = NSColor.white.cgColor
        contentView.translatesAutoresizingMaskIntoConstraints = false
        
        splitView.addArrangedSubview(sidebarView)
        splitView.addArrangedSubview(contentView)
        
        // ä¾§è¾¹æ å†…å®¹
        setupSidebar()
        
        // å³ä¾§å†…å®¹ï¼ˆä»…ä¿ç•™æ–°ç‰ˆåŒºåŸŸï¼‰
        // ä¸å†æ·»åŠ æ—§ç‰ˆæ ‡é¢˜/å°è®¡æ—¶å™¨åŒºåŸŸ
        setupTracksArea()
        setupBottomControls()
        setupStatusBar()
        
        // SplitView çº¦æŸ
        NSLayoutConstraint.activate([
            splitView.topAnchor.constraint(equalTo: topAnchor),
            splitView.leadingAnchor.constraint(equalTo: leadingAnchor),
            splitView.trailingAnchor.constraint(equalTo: trailingAnchor),
            splitView.bottomAnchor.constraint(equalTo: bottomAnchor),
            sidebarView.widthAnchor.constraint(equalToConstant: 300)
        ])
    }
    
    private func setupSidebar() {
        func styleHeader(_ tf: NSTextField, _ title: String) {
            tf.stringValue = title
            tf.isBordered = false
            tf.isEditable = false
            tf.backgroundColor = .clear
            tf.font = NSFont.systemFont(ofSize: 13, weight: .semibold)
            tf.textColor = NSColor.secondaryLabelColor
            tf.translatesAutoresizingMaskIntoConstraints = false
            sidebarView.addSubview(tf)
        }
        styleHeader(systemHeader, "ç³»ç»ŸéŸ³é¢‘è¾“å‡º")
        styleHeader(micHeader, "éº¦å…‹é£")
        styleHeader(appsHeader, "å·²æ‰“å¼€çš„åº”ç”¨")
        
        systemCheckbox.target = self
        systemCheckbox.action = #selector(sourceCheckboxChanged)
        systemCheckbox.translatesAutoresizingMaskIntoConstraints = false
        microphoneCheckbox.translatesAutoresizingMaskIntoConstraints = false
        microphoneCheckbox.target = self
        microphoneCheckbox.action = #selector(sourceCheckboxChanged)
        sidebarView.addSubview(systemCheckbox)
        sidebarView.addSubview(microphoneCheckbox)
        
        appsColumn.title = "Apps"
        appsTable.addTableColumn(appsColumn)
        appsTable.headerView = nil
        appsTable.rowSizeStyle = .default
        appsTable.usesAlternatingRowBackgroundColors = true
        appsTable.dataSource = self
        appsTable.delegate = self
        appsTable.rowHeight = 28
        appsTable.allowsMultipleSelection = true
        appsTable.translatesAutoresizingMaskIntoConstraints = false
        
        appsScroll.documentView = appsTable
        appsScroll.hasVerticalScroller = true
        appsScroll.translatesAutoresizingMaskIntoConstraints = false
        sidebarView.addSubview(appsScroll)
        
        NSLayoutConstraint.activate([
            systemHeader.topAnchor.constraint(equalTo: sidebarView.topAnchor, constant: 16),
            systemHeader.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 16),
            
            systemCheckbox.topAnchor.constraint(equalTo: systemHeader.bottomAnchor, constant: 8),
            systemCheckbox.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 16),
            
            micHeader.topAnchor.constraint(equalTo: systemCheckbox.bottomAnchor, constant: 18),
            micHeader.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 16),
            
            microphoneCheckbox.topAnchor.constraint(equalTo: micHeader.bottomAnchor, constant: 8),
            microphoneCheckbox.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 16),
            
            appsHeader.topAnchor.constraint(equalTo: microphoneCheckbox.bottomAnchor, constant: 18),
            appsHeader.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 16),
            
            appsScroll.topAnchor.constraint(equalTo: appsHeader.bottomAnchor, constant: 8),
            appsScroll.leadingAnchor.constraint(equalTo: sidebarView.leadingAnchor, constant: 12),
            appsScroll.trailingAnchor.constraint(equalTo: sidebarView.trailingAnchor, constant: -12),
            appsScroll.bottomAnchor.constraint(equalTo: sidebarView.bottomAnchor, constant: -12)
        ])
    }
    
    // æ—§ç‰ˆå†…å®¹åŒºåŸŸå·²ç§»é™¤

    private func setupTracksArea() {
        tracksStack.orientation = .vertical
        tracksStack.spacing = 12
        tracksStack.alignment = .leading
        tracksStack.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(tracksStack)

        func addPlaceholderTrack(_ title: String) {
            let row = NSView()
            row.translatesAutoresizingMaskIntoConstraints = false

            let icon = NSImageView()
            icon.image = NSImage(named: NSImage.touchBarAudioInputTemplateName)
            icon.translatesAutoresizingMaskIntoConstraints = false
            row.addSubview(icon)

            let label = NSTextField(labelWithString: title)
            label.font = NSFont.systemFont(ofSize: 14, weight: .semibold)
            label.alignment = .left
            label.translatesAutoresizingMaskIntoConstraints = false
            row.addSubview(label)

            let meter = LevelMeterView()
            meter.translatesAutoresizingMaskIntoConstraints = false
            row.addSubview(meter)

            NSLayoutConstraint.activate([
                icon.leadingAnchor.constraint(equalTo: row.leadingAnchor, constant: 8),
                icon.topAnchor.constraint(equalTo: row.topAnchor, constant: 8),
                icon.widthAnchor.constraint(equalToConstant: 16),
                icon.heightAnchor.constraint(equalToConstant: 16),

                label.leadingAnchor.constraint(equalTo: icon.trailingAnchor, constant: 8),
                label.centerYAnchor.constraint(equalTo: icon.centerYAnchor),
                label.trailingAnchor.constraint(lessThanOrEqualTo: row.trailingAnchor, constant: -8),

                meter.leadingAnchor.constraint(equalTo: row.leadingAnchor, constant: 8),
                meter.topAnchor.constraint(equalTo: icon.bottomAnchor, constant: 8),
                meter.trailingAnchor.constraint(equalTo: row.trailingAnchor, constant: -8),
                meter.heightAnchor.constraint(equalToConstant: 120),
                meter.bottomAnchor.constraint(equalTo: row.bottomAnchor, constant: -8)
            ])

            tracksStack.addArrangedSubview(row)
        }

        // åˆå§‹åŒ–æ ¹æ®å·¦ä¾§é€‰æ‹©ç”Ÿæˆè½¨é“
        func seedInitial() {
            if systemCheckbox.state == .on { addPlaceholderTrack("ç³»ç»Ÿæ‰¬å£°å™¨") }
            if microphoneCheckbox.state == .on { addPlaceholderTrack("éº¦å…‹é£") }
            let selectedRows = appsTable.selectedRowIndexes
            for idx in selectedRows { if idx >= 0 && idx < availableProcesses.count { addPlaceholderTrack(availableProcesses[idx].name) } }
        }
        seedInitial()

        NSLayoutConstraint.activate([
            tracksStack.topAnchor.constraint(equalTo: contentView.topAnchor, constant: 24),
            tracksStack.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
            tracksStack.trailingAnchor.constraint(equalTo: contentView.trailingAnchor, constant: -20)
        ])
    }

    private func setupBottomControls() {
        // å¤§è®¡æ—¶å™¨
        bigTimerLabel.stringValue = "00:00.00"
        bigTimerLabel.font = NSFont.monospacedDigitSystemFont(ofSize: 28, weight: .bold)
        bigTimerLabel.textColor = NSColor.secondaryLabelColor
        bigTimerLabel.backgroundColor = .clear
        bigTimerLabel.isBordered = false
        bigTimerLabel.isEditable = false
        bigTimerLabel.alignment = .left
        bigTimerLabel.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(bigTimerLabel)

        // å¤§å½•éŸ³æŒ‰é’®å®¹å™¨ï¼ˆå›ºå®šå¸ƒå±€+å¤–éƒ¨ç°è‰²æè¾¹ï¼‰
        bigButtonContainer.wantsLayer = true
        bigButtonContainer.layer?.backgroundColor = NSColor.clear.cgColor
        bigButtonContainer.layer?.masksToBounds = false
        bigButtonContainer.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(bigButtonContainer)

        // å¤–ç¯ï¼ˆç°è‰²æè¾¹ï¼Œç•™å‡ºä¸å†…éƒ¨æŒ‰é’®çš„é—´è·ï¼‰
        outerRingLayer.fillColor = NSColor.clear.cgColor
        outerRingLayer.strokeColor = NSColor(calibratedWhite: 0.0, alpha: 0.45).cgColor
        outerRingLayer.lineWidth = 8
        outerRingLayer.contentsScale = NSScreen.main?.backingScaleFactor ?? 2.0
        bigButtonContainer.layer?.addSublayer(outerRingLayer)

        // å¤§å½•éŸ³æŒ‰é’®ï¼ˆå†…éƒ¨å½¢çŠ¶ï¼Œåœ†â†”æ–¹åˆ‡æ¢ï¼‰
        bigRecordButton.title = ""
        bigRecordButton.isBordered = false
        bigRecordButton.wantsLayer = true
        bigRecordButton.layer?.backgroundColor = NSColor.systemRed.cgColor
        bigRecordButton.layer?.cornerRadius = 32
        bigRecordButton.target = self
        bigRecordButton.action = #selector(recordButtonClicked)
        bigRecordButton.translatesAutoresizingMaskIntoConstraints = false
        bigButtonContainer.addSubview(bigRecordButton)

        // å½•åˆ¶ä¸­è§†è§‰ï¼šå†…éƒ¨ç™½è‰²æ–¹å—ï¼ˆè¡¨ç¤ºåœæ­¢ï¼‰
        if let layer = bigRecordButton.layer {
            bigRecordInnerSquare.backgroundColor = NSColor.white.cgColor
            bigRecordInnerSquare.cornerRadius = 4
            bigRecordInnerSquare.isHidden = true
            // å…³é—­éšå¼åŠ¨ç”»ï¼Œé¿å…çº¦æŸåŠ¨ç”»æ—¶æ–¹å—å‡ºç°é—ªçƒæ”¾å¤§
            bigRecordInnerSquare.actions = [
                "bounds": NSNull(),
                "position": NSNull(),
                "hidden": NSNull(),
                "contents": NSNull()
            ]
            // åˆå§‹å°ºå¯¸ï¼Œåç»­åœ¨ layout è°ƒæ•´ä¸ºå±…ä¸­
            bigRecordInnerSquare.frame = CGRect(x: (layer.bounds.width - 22) / 2,
                                                y: (layer.bounds.height - 22) / 2,
                                                width: 22,
                                                height: 22)
            layer.addSublayer(bigRecordInnerSquare)
        }

        // å¸ƒå±€ï¼šå®¹å™¨å›ºå®šå¤§å°ï¼Œå†…éƒ¨æŒ‰é’®å›ºå®šå¤§å°ä¸å±…ä¸­ã€‚è®¡æ—¶å™¨ä¸å®¹å™¨å¯¹é½ï¼Œæ•´ä½“ä½ç½®ç¨³å®š
        let containerW = bigButtonContainer.widthAnchor.constraint(equalToConstant: 84)
        let containerH = bigButtonContainer.heightAnchor.constraint(equalToConstant: 84)
        let w = bigRecordButton.widthAnchor.constraint(equalToConstant: 64)
        let h = bigRecordButton.heightAnchor.constraint(equalToConstant: 64)
        bigRecordButtonWidthConstraint = w
        bigRecordButtonHeightConstraint = h
        NSLayoutConstraint.activate([
            bigButtonContainer.centerXAnchor.constraint(equalTo: contentView.centerXAnchor),
            bigButtonContainer.bottomAnchor.constraint(equalTo: contentView.bottomAnchor, constant: -40),
            containerW,
            containerH,

            bigRecordButton.centerXAnchor.constraint(equalTo: bigButtonContainer.centerXAnchor),
            bigRecordButton.centerYAnchor.constraint(equalTo: bigButtonContainer.centerYAnchor),
            w,
            h,

            bigTimerLabel.leadingAnchor.constraint(equalTo: contentView.leadingAnchor, constant: 20),
            bigTimerLabel.centerYAnchor.constraint(equalTo: bigButtonContainer.centerYAnchor)
        ])
    }

    private func setupStatusBar() {
        statusBarView.wantsLayer = true
        statusBarView.layer?.backgroundColor = NSColor(white: 0.96, alpha: 1).cgColor
        statusBarView.translatesAutoresizingMaskIntoConstraints = false
        contentView.addSubview(statusBarView)

        statusBarText.stringValue = "å‡†å¤‡å°±ç»ª"
        statusBarText.font = NSFont.systemFont(ofSize: 12)
        statusBarText.textColor = NSColor.secondaryLabelColor
        statusBarText.isBordered = false
        statusBarText.isEditable = false
        statusBarText.backgroundColor = .clear
        statusBarText.alignment = .left
        statusBarText.translatesAutoresizingMaskIntoConstraints = false
        statusBarView.addSubview(statusBarText)

        NSLayoutConstraint.activate([
            statusBarView.leadingAnchor.constraint(equalTo: contentView.leadingAnchor),
            statusBarView.trailingAnchor.constraint(equalTo: contentView.trailingAnchor),
            statusBarView.bottomAnchor.constraint(equalTo: contentView.bottomAnchor),
            statusBarView.heightAnchor.constraint(equalToConstant: 28),

            statusBarText.leadingAnchor.constraint(equalTo: statusBarView.leadingAnchor, constant: 12),
            statusBarText.centerYAnchor.constraint(equalTo: statusBarView.centerYAnchor)
        ])
    }
    
    // MARK: - Public Methods (MainViewController æœŸæœ›çš„æ–¹æ³•)
    func updateStatus(_ status: String) {
        // çŠ¶æ€å†™åˆ°åº•éƒ¨çŠ¶æ€æ 
        statusBarText.stringValue = status
    }
    
    func updateTimer(_ timeString: String) {
        // æ—¶é—´å†™åˆ°å¤§è®¡æ—¶å™¨
        bigTimerLabel.stringValue = timeString
    }
    
    func updateLevel(_ level: Float) {
        // å°†ç”µå¹³åˆ†å‘åˆ°å³ä¾§æ‰€æœ‰è½¨é“ä¸­çš„ LevelMeterView
        for row in tracksStack.arrangedSubviews {
            for sub in row.subviews {
                if let meter = sub as? LevelMeterView {
                    meter.updateLevel(level)
                }
            }
        }
    }
    
    func updateMode(_ mode: AudioUtils.RecordingMode) {
        // é¢„ç•™ï¼šå³ä¾§å¯åŠ å…¥æ¨¡å¼æ˜¾ç¤º
    }
    
    func updateRecordingState(_ state: RecordingState) {
        currentRecordingState = state
        switch state {
        case .idle:
            recordButton.title = "å¼€å§‹å½•éŸ³"
            recordButton.isEnabled = true
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemRed.cgColor
            bigRecordButton.layer?.cornerRadius = 32
        case .preparing:
            recordButton.title = "å‡†å¤‡ä¸­..."
            recordButton.isEnabled = false
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemRed.cgColor
            bigRecordButton.layer?.cornerRadius = 32
        case .recording:
            recordButton.title = "åœæ­¢å½•éŸ³"
            recordButton.isEnabled = true
            // å¤–å½¢åˆ‡æ¢ä¸ºæ–¹å½¢åœæ’­æ ·å¼
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemGray.cgColor
            bigRecordButton.layer?.cornerRadius = 10
        case .stopping:
            recordButton.title = "åœæ­¢ä¸­..."
            recordButton.isEnabled = false
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemGray.cgColor
            bigRecordButton.layer?.cornerRadius = 10
        case .playing:
            recordButton.title = "æ’­æ”¾ä¸­..."
            recordButton.isEnabled = false
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemRed.cgColor
            bigRecordButton.layer?.cornerRadius = 32
        case .error:
            recordButton.title = "å¼€å§‹å½•éŸ³"
            recordButton.isEnabled = true
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.backgroundColor = NSColor.systemRed.cgColor
            bigRecordButton.layer?.cornerRadius = 32
        }
    }
    
    func debugButtonPosition() {}
    
    // MARK: - Actions
    @objc private func recordButtonClicked() {
        switch currentRecordingState {
        case .idle, .error:
            // ç«‹å³ç»™å‡ºè§†è§‰åé¦ˆ
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.cornerRadius = 10
            delegate?.mainWindowViewDidStartRecording(self)
        case .preparing, .recording:
            bigRecordInnerSquare.isHidden = true
            bigRecordButton.layer?.cornerRadius = 10
            delegate?.mainWindowViewDidStopRecording(self)
        case .stopping, .playing:
            break
        }
    }

    @objc private func sourceCheckboxChanged() {
        rebuildTracks()
    }

    private func rebuildTracks() {
        // æ¸…ç©ºç°æœ‰è½¨é“
        for v in tracksStack.arrangedSubviews {
            tracksStack.removeArrangedSubview(v)
            v.removeFromSuperview()
        }
        // ä¾æ®å‹¾é€‰ä¸é€‰æ‹©é‡å»º
        if systemCheckbox.state == .on { addTrackRow(title: "ç³»ç»Ÿæ‰¬å£°å™¨") }
        if microphoneCheckbox.state == .on { addTrackRow(title: "éº¦å…‹é£") }
        let selected = appsTable.selectedRowIndexes
        for idx in selected { if idx >= 0 && idx < availableProcesses.count { addTrackRow(title: availableProcesses[idx].name) } }
    }

    private func addTrackRow(title: String) {
        let row = NSView()
        row.translatesAutoresizingMaskIntoConstraints = false
        let icon = NSImageView()
        icon.image = NSImage(named: NSImage.touchBarAudioInputTemplateName)
        icon.translatesAutoresizingMaskIntoConstraints = false
        row.addSubview(icon)
        let label = NSTextField(labelWithString: title)
        label.font = NSFont.systemFont(ofSize: 14, weight: .semibold)
        label.alignment = .left
        label.translatesAutoresizingMaskIntoConstraints = false
        row.addSubview(label)
        let meter = LevelMeterView()
        meter.translatesAutoresizingMaskIntoConstraints = false
        row.addSubview(meter)
        NSLayoutConstraint.activate([
            icon.leadingAnchor.constraint(equalTo: row.leadingAnchor, constant: 8),
            icon.topAnchor.constraint(equalTo: row.topAnchor, constant: 8),
            icon.widthAnchor.constraint(equalToConstant: 16),
            icon.heightAnchor.constraint(equalToConstant: 16),
            label.leadingAnchor.constraint(equalTo: icon.trailingAnchor, constant: 8),
            label.centerYAnchor.constraint(equalTo: icon.centerYAnchor),
            label.trailingAnchor.constraint(lessThanOrEqualTo: row.trailingAnchor, constant: -8),
            meter.leadingAnchor.constraint(equalTo: row.leadingAnchor, constant: 8),
            meter.topAnchor.constraint(equalTo: icon.bottomAnchor, constant: 8),
            meter.trailingAnchor.constraint(equalTo: row.trailingAnchor, constant: -8),
            meter.heightAnchor.constraint(equalToConstant: 120),
            meter.bottomAnchor.constraint(equalTo: row.bottomAnchor, constant: -8)
        ])
        tracksStack.addArrangedSubview(row)
    }
    
    // MARK: - Table DataSource / Delegate
    func numberOfRows(in tableView: NSTableView) -> Int {
        return availableProcesses.count
    }
    
    func tableView(_ tableView: NSTableView, viewFor tableColumn: NSTableColumn?, row: Int) -> NSView? {
        let id = NSUserInterfaceItemIdentifier("AppCell")
        let cell: NSTableCellView
        if let reused = tableView.makeView(withIdentifier: id, owner: self) as? NSTableCellView {
            cell = reused
        } else {
            cell = NSTableCellView()
            cell.identifier = id
            let imageView = NSImageView()
            imageView.translatesAutoresizingMaskIntoConstraints = false
            imageView.image = NSImage(named: NSImage.multipleDocumentsName)
            imageView.wantsLayer = true
            imageView.layer?.cornerRadius = 4
            cell.addSubview(imageView)
            let text = NSTextField(labelWithString: "")
            text.translatesAutoresizingMaskIntoConstraints = false
            cell.addSubview(text)
            cell.imageView = imageView
            cell.textField = text
            NSLayoutConstraint.activate([
                imageView.leadingAnchor.constraint(equalTo: cell.leadingAnchor, constant: 8),
                imageView.centerYAnchor.constraint(equalTo: cell.centerYAnchor),
                imageView.widthAnchor.constraint(equalToConstant: 18),
                imageView.heightAnchor.constraint(equalToConstant: 18),
                text.leadingAnchor.constraint(equalTo: imageView.trailingAnchor, constant: 8),
                text.centerYAnchor.constraint(equalTo: cell.centerYAnchor),
                text.trailingAnchor.constraint(equalTo: cell.trailingAnchor, constant: -8)
            ])
        }
        if row < availableProcesses.count {
            let process = availableProcesses[row]
            cell.textField?.stringValue = "\(process.name) (PID: \(process.pid))"
        }
        return cell
    }

    func tableViewSelectionDidChange(_ notification: Notification) {
        updateTracksDisplay()
        // åŒæ­¥æ‰€é€‰è¿›ç¨‹PIDç»™ä¸Šå±‚æ§åˆ¶å™¨
        let selectedRows = appsTable.selectedRowIndexes
        var pids: [pid_t] = []
        for index in selectedRows {
            if index < availableProcesses.count {
                pids.append(availableProcesses[index].pid)
            }
        }
        delegate?.mainWindowViewDidSelectProcesses(self, pids: pids)
    }

    override func layout() {
        super.layout()
        // æ›´æ–°å†…æ–¹å—ï¼ˆè‹¥å¯ç”¨ï¼‰çš„ä½ç½®ä¸å¤–ç¯è·¯å¾„ï¼Œä¿æŒå¸ƒå±€ä¸å˜
        if let layer = bigRecordButton.layer {
            let size: CGFloat = 22
            bigRecordInnerSquare.frame = CGRect(x: (layer.bounds.width - size) / 2,
                                                y: (layer.bounds.height - size) / 2,
                                                width: size,
                                                height: size)
        }
        // å¤–ç¯è·¯å¾„ï¼šä»¥å®¹å™¨ä¸­é—´ä¸ºåœ†å¿ƒï¼Œç¨å¤§äºå†…éƒ¨æŒ‰é’®ï¼Œä¿ç•™é—´è·
        let bounds = bigButtonContainer.bounds
        if bounds.width > 0 && bounds.height > 0 {
            outerRingLayer.frame = bounds
            let center = CGPoint(x: bounds.midX, y: bounds.midY)
            let radius = min(bounds.width, bounds.height) / 2 - outerRingLayer.lineWidth / 2 - 1
            let path = NSBezierPath()
            path.appendArc(withCenter: NSPoint(x: center.x, y: center.y), radius: radius, startAngle: 0, endAngle: 360)
            // æ„é€  CGPath å…¼å®¹æ—§ç³»ç»Ÿ
            let cgPath = CGMutablePath()
            cgPath.addArc(center: CGPoint(x: center.x, y: center.y), radius: radius, startAngle: 0, endAngle: CGFloat.pi * 2, clockwise: false)
            outerRingLayer.path = cgPath
        }
    }

    // ä¿ç•™ç©ºå®ç°ï¼ˆå ä½ï¼Œåç»­å¦‚éœ€æ¢å¤å°ºå¯¸åŠ¨ç”»å¯å¤ç”¨ï¼‰
    private func resizeBigRecordButton(to size: CGFloat) { }
}

// MARK: - Delegate Protocol
protocol MainWindowViewDelegate: AnyObject {
    func mainWindowViewDidSwitchMode(_ view: MainWindowView)
    func mainWindowViewDidStartRecording(_ view: MainWindowView)
    func mainWindowViewDidStopRecording(_ view: MainWindowView)
    func mainWindowViewDidPlayRecording(_ view: MainWindowView)
    func mainWindowViewDidDownloadRecording(_ view: MainWindowView)
    func mainWindowViewDidChangeFormat(_ view: MainWindowView, format: String)
    func mainWindowViewDidOpenPermissions(_ view: MainWindowView)
    func mainWindowViewDidStopPlayback(_ view: MainWindowView)
    func mainWindowViewDidSelectProcesses(_ view: MainWindowView, pids: [pid_t])
}

// MARK: - Process List Management
extension MainWindowView {
    /// æ›´æ–°è¿›ç¨‹åˆ—è¡¨
    func updateProcessList(_ processes: [AudioProcessInfo]) {
        availableProcesses = processes
        appsTable.reloadData()
    }
    
    /// æ›´æ–°è½¨é“æ˜¾ç¤º
    func updateTracksDisplay() {
        // æ¸…é™¤ç°æœ‰è½¨é“
        tracksStack.arrangedSubviews.forEach { $0.removeFromSuperview() }
        
        // æ ¹æ®é€‰æ‹©æ·»åŠ è½¨é“
        if systemCheckbox.state == .on {
            addTrackRow(icon: "ğŸ”Š", title: "ç³»ç»ŸéŸ³é¢‘è¾“å‡º", isActive: true)
        }
        if microphoneCheckbox.state == .on {
            addTrackRow(icon: "ğŸ¤", title: "éº¦å…‹é£", isActive: true)
        }
        
        // æ·»åŠ é€‰ä¸­çš„è¿›ç¨‹è½¨é“
        let selectedRows = appsTable.selectedRowIndexes
        for index in selectedRows {
            if index < availableProcesses.count {
                let process = availableProcesses[index]
                addTrackRow(icon: "ğŸ“±", title: process.name, isActive: true)
            }
        }
    }
    
    /// æ·»åŠ è½¨é“è¡Œ
    private func addTrackRow(icon: String, title: String, isActive: Bool) {
        let trackView = NSView()
        trackView.translatesAutoresizingMaskIntoConstraints = false
        
        let iconLabel = NSTextField()
        iconLabel.stringValue = icon
        iconLabel.isBordered = false
        iconLabel.isEditable = false
        iconLabel.backgroundColor = .clear
        iconLabel.font = NSFont.systemFont(ofSize: 16)
        iconLabel.translatesAutoresizingMaskIntoConstraints = false
        
        let titleLabel = NSTextField()
        titleLabel.stringValue = title
        titleLabel.isBordered = false
        titleLabel.isEditable = false
        titleLabel.backgroundColor = .clear
        titleLabel.font = NSFont.systemFont(ofSize: 13)
        titleLabel.textColor = .labelColor
        titleLabel.translatesAutoresizingMaskIntoConstraints = false
        
        let levelMeter = LevelMeterView()
        levelMeter.translatesAutoresizingMaskIntoConstraints = false
        
        trackView.addSubview(iconLabel)
        trackView.addSubview(titleLabel)
        trackView.addSubview(levelMeter)
        
        NSLayoutConstraint.activate([
            trackView.heightAnchor.constraint(equalToConstant: 40),
            
            iconLabel.leadingAnchor.constraint(equalTo: trackView.leadingAnchor, constant: 16),
            iconLabel.centerYAnchor.constraint(equalTo: trackView.centerYAnchor),
            
            titleLabel.leadingAnchor.constraint(equalTo: iconLabel.trailingAnchor, constant: 12),
            titleLabel.centerYAnchor.constraint(equalTo: trackView.centerYAnchor),
            
            levelMeter.leadingAnchor.constraint(equalTo: titleLabel.trailingAnchor, constant: 16),
            levelMeter.trailingAnchor.constraint(equalTo: trackView.trailingAnchor, constant: -16),
            levelMeter.centerYAnchor.constraint(equalTo: trackView.centerYAnchor),
            levelMeter.heightAnchor.constraint(equalToConstant: 20)
        ])
        
        tracksStack.addArrangedSubview(trackView)
    }
}

// MARK: - Public Query APIs
extension MainWindowView {
    func isSystemAudioSourceSelected() -> Bool { systemCheckbox.state == .on }
    func isMicrophoneSourceSelected() -> Bool { microphoneCheckbox.state == .on }
}
